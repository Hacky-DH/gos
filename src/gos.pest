// GOS (Graph Representation Language) Grammar for Pest Parser
// Based on the Python PLY implementation

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = {
    "#" ~ (!"\n" ~ ANY)* |
    "//" ~ (!"\n" ~ ANY)* |
    "/*" ~ (!"*/" ~ ANY)* ~ "*/"
}

// Keywords
graph = { "graph" }
op = { "op" }
node = { "node" }
edge = { "edge" }
var = { "var" }
meta = { "meta" }
import = { "import" }
as_keyword = { "as" }
from = { "from" }
ref = { "ref" }
for = { "for" }
in = { "in" }
if_keyword = { "if" }
or = { "or" }
else_keyword = { "else" }

// Reserved words
input = { "input" }
output = { "output" }
depend = { "depend" }
version = { "version" }
with = { "with" }
date = { "date" }
config = { "config" }
name = { "name" }
dtype = { "dtype" }
default = { "default" }
pattern = { "pattern" }
help = { "help" }
choice = { "choice" }
length = { "length" }
range = { "range" }
condition = { "condition" }
property = { "property" }
url = { "url" }
fname = { "fname" }
null = { "null" }
override = { "override" }
log = { "log" }
metrics = { "metrics" }
funnel = { "funnel" }

// Literals
BOOL = { "true" | "false" | "True" | "False" }
NULL = { "null" }

// Numbers
NUMBER = @{ ("+" | "-")? ~ ASCII_DIGIT+ }
FLOAT = @{ 
    ("+" | "-")? ~ (
        ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* |
        "." ~ ASCII_DIGIT+ |
        ASCII_DIGIT+ ~ "."
    ) ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? |
    ("+" | "-")? ~ ASCII_DIGIT+ ~ ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+
}

// DateTime (deprecated but still supported)
DATETIME = @{ ASCII_DIGIT{4} ~ "-" ~ ASCII_DIGIT{2} ~ "-" ~ ASCII_DIGIT{2} ~ "T" ~ ASCII_DIGIT{2} ~ ":" ~ ASCII_DIGIT{2} ~ ":" ~ ASCII_DIGIT{2} ~ "Z" }

// Strings
STRING = @{ 
    "\"" ~ (!"\"" ~ (("\\" ~ ANY) | (!"\\" ~ !"\n" ~ ANY)))* ~ "\"" |
    "'" ~ (!"'" ~ (("\\" ~ ANY) | (!"\\" ~ !"\n" ~ ANY)))* ~ "'"
}

MULTI_LINE_STRING = @{
    "\"\"\"" ~ (!"\"\"\"" ~ ANY)* ~ "\"\"\"" |
    "'''" ~ (!"'''" ~ ANY)* ~ "'''"
}

ID_STRING = @{
    ASCII_ALPHA_LOWER ~ (
        "\"" ~ (!"\"" ~ (("\\" ~ ANY) | (!"\\" ~ !"\n" ~ ANY)))* ~ "\"" |
        "'" ~ (!"'" ~ (("\\" ~ ANY) | (!"\\" ~ !"\n" ~ ANY)))* ~ "'"
    )
}

// Identifiers
IDENTIFIER = @{ 
    !("-"? ~ ASCII_DIGIT+ ~ (("e" | "E") ~ "-"? ~ ASCII_DIGIT+)?) ~
    (ASCII_ALPHA | "_" | "$" | "%" | "@" | "-") ~ 
    (ASCII_ALPHANUMERIC | "_" | "$" | "%" | "@" | "-")*
}

// Operators
DEFINED_BY = { "=" }
OP_GT = { ">" }
OP_GE = { ">=" }
OP_LT = { "<" }
OP_LE = { "<=" }
OP_EQ = { "==" }
OP_NE = { "!=" }
OP_MATCH = { "~=" }

// Delimiters
COMMA = { "," }
LBRACE = { "{" }
RBRACE = { "}" }
LPAREN = { "(" }
RPAREN = { ")" }
LBRACKET = { "[" }
RBRACKET = { "]" }
COLON = { ":" }
DOT = { "." }
ENDMARKER = { ";" }
QUESTION = { "?" }

// Main grammar rules
gos = { SOI ~ statements? ~ EOI }

statements = { statement_def+ }

statement_def = { statement_end | COMMENT }

statement_end = { all_statements ~ ENDMARKER? }

all_statements = {
    var_def |
    import_def |
    graph_def |
    op_def |
    node_def
}

// Variable definitions
var_def = { var ~ LBRACE ~ attr_defs? ~ RBRACE ~ (as_keyword ~ all_identifier)? }

attr_defs = { attr_def_comment+ }
attr_def_comment = { attr_def ~ ENDMARKER? | COMMENT }

attr_def = {
    dotted_name ~ DEFINED_BY ~ value ~ (if_keyword ~ if_condition)? ~ (else_keyword ~ value)?
}

// Import definitions
import_def = { import ~ dotted_as_names }
dotted_as_names = { dotted_as_name ~ (COMMA ~ dotted_as_name)* }
dotted_as_name = { dotted_name ~ (as_keyword ~ all_identifier)? }
dotted_name = @{ all_identifier ~ (DOT ~ all_identifier)* }

// Graph definitions
graph_def = { (graph | graph_template) ~ LBRACE ~ graph_block ~ RBRACE ~ (as_keyword ~ as_stmt)? }
graph_template = { graph ~ COLON ~ as_stmt }

as_stmt = { dotted_name ~ (LPAREN ~ STRING ~ RPAREN)? }

graph_block = { graph_stmt* }
graph_stmt = { comma_dotted_names ~ DEFINED_BY ~ graph_value ~ ENDMARKER? | COMMENT }

graph_value = {
    condition_section |
    node_block |
    value |
    comma_dotted_names |
    for_loop_block
}

comma_dotted_names = { dotted_name ~ (COMMA ~ dotted_name)* }

// Node definitions
node_def = { comma_dotted_names ~ DEFINED_BY ~ (node_block | for_loop_block) }

node_block = {
    dotted_name ~ LPAREN ~ inputs_def? ~ RPAREN ~ node_attrs* |
    ref ~ LPAREN ~ dotted_name ~ LPAREN ~ inputs_def? ~ RPAREN ~ RPAREN ~ node_attrs*
}

node_attrs = {
    DOT ~ name ~ LPAREN ~ STRING ~ RPAREN |
    DOT ~ version ~ LPAREN ~ STRING ~ RPAREN |
    DOT ~ depend ~ LPAREN ~ comma_dotted_names ~ RPAREN |
    DOT ~ with ~ LPAREN ~ node_param_block ~ RPAREN |
    DOT ~ as_keyword ~ LPAREN ~ all_identifier ~ RPAREN |
    DOT ~ condition ~ LPAREN ~ STRING ~ RPAREN |
    DOT ~ property ~ LPAREN ~ node_param_block ~ RPAREN |
    DOT ~ override ~ LPAREN ~ override_param? ~ RPAREN |
    DOT ~ log ~ LPAREN ~ node_param_block ~ RPAREN |
    DOT ~ metrics ~ LPAREN ~ node_param_block ~ RPAREN |
    DOT ~ funnel ~ LPAREN ~ node_param_block ~ RPAREN
}

inputs_def = { inputs_key_defs | inputs_tuple_def }
one_inputs_def = { dotted_name | value }
inputs_tuple_def = { one_inputs_def ~ (COMMA ~ one_inputs_def)* }

inputs_key_defs = { inputs_key_def ~ (COMMA ~ inputs_key_def)* }
inputs_key_def = { dotted_name ~ DEFINED_BY ~ one_inputs_def }

node_param_block = { node_param_comment+ }
node_param_comment = { param_def ~ COMMA? | COMMENT }
param_def = { attr_def | ref_def }

ref_def = {
    dotted_name ~ DEFINED_BY ~ dotted_name ~ (if_keyword ~ if_condition)? ~ (or ~ value)?
}

if_condition = { MULTI_LINE_STRING | STRING | dotted_name }

// For loop blocks
for_loop_block = {
    LBRACKET ~ for_loop_block_no_if ~ (if_keyword ~ if_condition)? ~ RBRACKET
}
for_loop_block_no_if = { node_block ~ for ~ comma_dotted_names ~ in ~ dotted_name }

override_param = { NUMBER | BOOL }

// Condition definitions
condition_section = { condition_stmt ~ QUESTION ~ condition_node_stmt ~ COLON ~ condition_node_stmt }
condition_node_stmt = { condition_section | node_block }

condition_stmt = {
    if_condition |
    comparison_stmt |
    LPAREN ~ comparison_stmt ~ RPAREN |
    node_block
}

comparison_stmt = {
    comparison_gt | comparison_ge | comparison_lt |
    comparison_le | comparison_eq | comparison_ne | comparison_match
}

comparison_gt = { operand2 ~ OP_GT ~ operand2 }
comparison_ge = { operand2 ~ OP_GE ~ operand2 }
comparison_lt = { operand2 ~ OP_LT ~ operand2 }
comparison_le = { operand2 ~ OP_LE ~ operand2 }
comparison_eq = { operand3 ~ OP_EQ ~ operand3 }
comparison_ne = { operand3 ~ OP_NE ~ operand3 }
comparison_match = { all_identifier ~ OP_MATCH ~ STRING }

operand2 = { NUMBER | all_identifier }
operand3 = { NUMBER | STRING | all_identifier }

// Op definitions
op_def = { op ~ LBRACE ~ op_block ~ RBRACE ~ (as_keyword ~ as_stmt)? }

op_block = { op_stmt* }
op_stmt = { op_sections }

op_sections = { op_section_comment+ }
op_section_comment = { op_section ~ ENDMARKER? | COMMENT }
op_section = { op_meta_def | op_input_def | op_output_def | op_config_def | sub_graph_def }

op_meta_def = { meta ~ LBRACE ~ op_meta_block ~ RBRACE }
op_meta_block = { op_meta_stmt_comment* }
op_meta_stmt_comment = { param_def ~ ENDMARKER? | COMMENT }

op_input_def = { input ~ LBRACE ~ op_spec_stmts ~ RBRACE }
op_output_def = { output ~ LBRACE ~ op_spec_stmts ~ RBRACE }
op_config_def = { config ~ LBRACE ~ op_spec_stmts ~ RBRACE }

op_spec_stmts = { op_spec_stmt* }
op_spec_stmt = { (all_identifier ~ COLON ~ op_spec_def_end) | COMMENT }
op_spec_def_end = { op_spec_def ~ ENDMARKER? }
op_spec_def = { op_spec_dtype_def | LPAREN ~ op_spec_key_defs ~ RPAREN }

op_spec_dtype_def = { all_identifier | date }
op_spec_key_defs = { op_spec_key_def ~ (COMMA ~ op_spec_key_def)* ~ COMMA? }
op_spec_key_def = {
    op_spec_dtype_def_dict | op_spec_default_def | op_spec_pattern_def |
    op_spec_help_def | op_spec_choice_def | op_spec_length_def |
    op_spec_range_def | op_spec_url_def | op_spec_fname_def
}

op_spec_dtype_def_dict = { dtype ~ DEFINED_BY ~ (all_identifier | date) }
op_spec_default_def = { default_def | default_ref_def }
default_def = { default ~ DEFINED_BY ~ value }
default_ref_def = { default ~ DEFINED_BY ~ dotted_name }
op_spec_pattern_def = { pattern ~ DEFINED_BY ~ STRING }
op_spec_help_def = { help ~ DEFINED_BY ~ STRING }
op_spec_choice_def = { choice ~ DEFINED_BY ~ tuple_stmt }
op_spec_length_def = { length ~ DEFINED_BY ~ (fix_length | closed_interval) }
op_spec_range_def = { range ~ DEFINED_BY ~ mix_interval }
op_spec_url_def = { url ~ DEFINED_BY ~ STRING }
op_spec_fname_def = { fname ~ DEFINED_BY ~ STRING }

fix_length = { NUMBER }
closed_interval = {
    LBRACKET ~ NUMBER ~ COMMA ~ NUMBER ~ RBRACKET |
    LBRACKET ~ NUMBER ~ COMMA ~ RBRACKET |
    LBRACKET ~ COMMA ~ NUMBER ~ RBRACKET
}
mix_interval = {
    left_interval ~ NUMBER ~ COMMA ~ NUMBER ~ right_interval |
    left_interval ~ NUMBER ~ COMMA ~ right_interval |
    left_interval ~ COMMA ~ NUMBER ~ right_interval
}
left_interval = { LBRACKET | LPAREN }
right_interval = { RBRACKET | RPAREN }

sub_graph_def = { graph_def }

// Values
value = {
    MULTI_LINE_STRING | STRING | FLOAT | BOOL | DATETIME |
    NUMBER | NULL | date_stmt | dict_stmt | list_stmt | tuple_stmt | set_stmt
}

dict_stmt = { LBRACE ~ dict_block ~ RBRACE }
dict_block = { (key_value ~ (COMMA ~ key_value)* ~ COMMA?)? }
key_value = { STRING ~ COLON ~ value }

list_stmt = { LBRACKET ~ list_block ~ RBRACKET }
list_block = { (value ~ (COMMA ~ value)* ~ COMMA?)? }

tuple_stmt = { LPAREN ~ tuple_block ~ RPAREN }
tuple_block = { (value ~ (COMMA ~ value)* ~ COMMA?)? }

set_stmt = { LBRACE ~ set_block ~ RBRACE }
set_block = { (value ~ (COMMA ~ value)+ ~ COMMA?) | (value ~ COMMA) }

date_stmt = { date ~ LPAREN ~ STRING ~ RPAREN }

keywords = {
    graph | op | node | edge | var | meta | import | as_keyword | from | ref | for | in | if_keyword | or | else_keyword |
    input | output | depend | version | with | date | config | name | dtype | default |
    pattern | help | choice | length | range | condition | property | url | fname | null |
    override | log | metrics | funnel
}

// Identifiers
all_identifier = { IDENTIFIER | ID_STRING | keywords }
