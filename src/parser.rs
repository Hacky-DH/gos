//! GOS parser implementation using Pest
//!
//! This module contains the main parser logic that converts GOS source code
//! into AST nodes.
#![allow(dead_code)]

use chrono::{DateTime, Utc};
use pest_derive::Parser;
use regex::Regex;

use crate::ast::*;
use crate::error::{ErrorCollection, ParseError, ParseResult};

#[derive(Parser)]
#[grammar = "gos.pest"]
pub struct GosParser;

// Rule enum is automatically generated by pest derive macro

/// Parse options for controlling parser behavior
#[derive(Debug, Clone, Default)]
pub struct ParseOptions {
    /// Return AST nodes instead of plain data structures
    pub ast: bool,
    /// Include symbol information
    pub symbol: bool,
    /// Collect errors instead of failing immediately
    pub error: bool,
    /// Enable position tracking
    pub tracking: bool,
    /// Enable debug mode
    pub debug: bool,
}

/// Main parsing function - entry point for GOS parsing
pub fn parse_gos(content: &str, options: ParseOptions) -> ParseResult<AstNodeEnum> {
    let mut parser = GosParserImpl::new(options);
    parser.parse(content)
}

/// Internal parser implementation
struct GosParserImpl {
    options: ParseOptions,
    errors: ErrorCollection,
    unicode_escape_tool: UnicodeEscapeTool,
}

impl GosParserImpl {
    fn new(options: ParseOptions) -> Self {
        Self {
            options,
            errors: ErrorCollection::new(),
            unicode_escape_tool: UnicodeEscapeTool::new(),
        }
    }

    fn debug(&self, pair: &pest::iterators::Pair<Rule>) {
        if self.options.debug {
            let pair_str = pair.as_str();
            let truncated = if pair_str.len() > 50 {
                &pair_str[..50]
            } else {
                pair_str
            };
            eprintln!(
                "DEBUG parse rule {:?}, content {:?}",
                pair.as_rule(),
                truncated
            );
        }
    }

    fn parse(&mut self, content: &str) -> ParseResult<AstNodeEnum> {
        use pest::Parser;
        let pairs = GosParser::parse(Rule::gos, content).map_err(|e| ParseError::from(e))?;

        let mut result = None;
        for pair in pairs {
            self.debug(&pair);
            match pair.as_rule() {
                Rule::gos => {
                    result = Some(self.parse_gos_root(pair)?);
                    break;
                }
                _ => unreachable!(),
            }
        }

        match result {
            Some(ast) => {
                if self.options.error && self.errors.has_errors() {
                    self.errors.clone().into_result(ast)
                } else {
                    Ok(ast)
                }
            }
            None => Err(ParseError::general("No valid GOS content found")),
        }
    }

    fn parse_gos_root(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        let mut statements = Vec::new();
        let start_pos = self.get_position(&pair);

        for inner_pair in pair.into_inner() {
            self.debug(&inner_pair);
            match inner_pair.as_rule() {
                Rule::statements => {
                    for stmt_pair in inner_pair.into_inner() {
                        self.debug(&stmt_pair);
                        statements.push(self.parse_statement_def(stmt_pair)?);
                    }
                }
                Rule::COMMENT => {
                    statements.push(self.parse_comment(inner_pair)?);
                }
                Rule::EOI => break,
                _ => {}
            }
        }

        if statements.is_empty() {
            return Ok(AstNodeEnum::Module(Module {
                position: start_pos,
                children: vec![],
            }));
        }

        let first_pos = statements.first().unwrap().position().clone();
        let end_pos = statements.last().unwrap().position().clone();
        let position = Position {
            line: first_pos.line,
            end_line: end_pos.end_line,
            start: first_pos.start,
            end: end_pos.end,
        };

        Ok(AstNodeEnum::Module(Module {
            position,
            children: statements,
        }))
    }

    fn parse_statement_def(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        if pair.as_rule() == Rule::COMMENT {
            return self.parse_comment(pair);
        }
        for inner_pair in pair.into_inner() {
            self.debug(&inner_pair);
            if inner_pair.as_rule() == Rule::statement_end {
                return self.parse_statement_end(inner_pair);
            }
        }
        Err(ParseError::general("Empty statement def"))
    }

    fn parse_statement_end(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        for inner_pair in pair.into_inner() {
            self.debug(&inner_pair);
            match inner_pair.as_rule() {
                Rule::all_statements => return self.parse_all_statements(inner_pair),
                Rule::ENDMARKER => {} // Skip semicolon
                _ => {}
            }
        }
        Err(ParseError::general("Empty statement"))
    }

    fn parse_all_statements(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        for inner_pair in pair.into_inner() {
            self.debug(&inner_pair);
            match inner_pair.as_rule() {
                Rule::var_def => return self.parse_var_def(inner_pair),
                Rule::import_def => return self.parse_import_def(inner_pair),
                Rule::graph_def => return self.parse_graph_def(inner_pair),
                Rule::op_def => return self.parse_op_def(inner_pair),
                Rule::node_def => return self.parse_node_def(inner_pair),
                _ => {}
            }
        }
        Err(ParseError::general("Unknown statement type"))
    }

    fn parse_var_def(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut children = Vec::new();
        let mut alias = None;
        let offset = None;

        let mut has_as = false;
        for inner_pair in pair.into_inner() {
            self.debug(&inner_pair);
            match inner_pair.as_rule() {
                Rule::LBRACE | Rule::RBRACE | Rule::var => {
                    // skip var{}
                }
                Rule::as_keyword => {
                    has_as = true;
                }
                Rule::all_identifier => {
                    if has_as {
                        alias = Some(self.parse_symbol(inner_pair, SymbolKind::VarAsName)?);
                    }
                }
                Rule::attr_defs => {
                    for attr_def_end_pair in inner_pair.into_inner() {
                        self.debug(&attr_def_end_pair);
                        if let Ok(attr) = self.attr_def_comment(attr_def_end_pair) {
                            children.push(attr);
                        }
                    }
                }
                Rule::COMMENT => {
                    children.push(self.parse_comment(inner_pair)?);
                }
                _ => {}
            }
        }

        Ok(AstNodeEnum::VarDef(VarDef {
            position,
            children,
            alias,
            offset,
        }))
    }

    fn attr_def_comment(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        if pair.as_rule() == Rule::COMMENT {
            return self.parse_comment(pair);
        }
        for inner_pair in pair.into_inner() {
            self.debug(&inner_pair);
            if inner_pair.as_rule() == Rule::attr_def {
                return self.parse_attr_def(inner_pair);
            }
        }
        Err(ParseError::general("Invalid attribute definition"))
    }

    fn parse_attr_def(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut inner_pairs = pair.into_inner();
        let name_pair = inner_pairs.next().ok_or_else(|| {
            ParseError::syntax_error(position.line, position.start, "Expected attribute name")
        })?;
        self.debug(&name_pair);
        let name = self.parse_symbol(name_pair, SymbolKind::VarAttr)?;

        // Skip DEFINED_BY (=)
        inner_pairs.next();

        let value_pair = inner_pairs.next().ok_or_else(|| {
            ParseError::syntax_error(position.line, position.start, "Expected attribute value")
        })?;
        self.debug(&value_pair);
        let value = self.parse_value(value_pair)?;

        let mut condition = None;
        let mut else_value = None;

        // Parse optional if/else clauses
        while let Some(next_pair) = inner_pairs.next() {
            match next_pair.as_rule() {
                Rule::if_keyword => {
                    if let Some(cond_pair) = inner_pairs.next() {
                        self.debug(&cond_pair);
                        condition = Some(self.parse_if_condition(cond_pair)?);
                    }
                }
                Rule::else_keyword => {
                    if let Some(else_pair) = inner_pairs.next() {
                        self.debug(&else_pair);
                        else_value = Some(self.parse_value(else_pair)?);
                    }
                }
                _ => {}
            }
        }

        Ok(AstNodeEnum::AttrDef(AttrDef {
            position,
            name,
            value: Box::new(value),
            condition: condition.map(Box::new),
            else_value: else_value.map(Box::new),
        }))
    }

    fn parse_import_def(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::import => continue, // Skip import keyword
                Rule::dotted_as_names => {
                    items = self.parse_dotted_as_names(inner_pair)?;
                }
                _ => {}
            }
        }

        Ok(AstNodeEnum::Import(Import { position, items }))
    }

    fn parse_dotted_as_names(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<Vec<ImportItem>> {
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::dotted_as_name {
                items.push(self.parse_dotted_as_name(inner_pair)?);
            }
        }

        Ok(items)
    }

    fn parse_dotted_as_name(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<ImportItem> {
        let position = self.get_position(&pair);
        let mut path = None;
        let mut alias = None;

        let mut inner_pairs = pair.into_inner();

        if let Some(dotted_name_pair) = inner_pairs.next() {
            path =
                Some(self.parse_dotted_name_as_symbol(dotted_name_pair, SymbolKind::ImportName)?);
        }

        // Check for 'as' clause
        if let Some(as_pair) = inner_pairs.next() {
            if as_pair.as_rule() == Rule::as_keyword {
                if let Some(identifier_pair) = inner_pairs.next() {
                    alias = Some(self.parse_symbol(identifier_pair, SymbolKind::ImportAsName)?);
                }
            }
        }

        Ok(ImportItem {
            position,
            path: path.ok_or_else(|| ParseError::general("Missing import path"))?,
            alias,
        })
    }

    fn parse_graph_def(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut children = Vec::new();
        let mut alias = None;
        let version = None;
        let template_graph = None;
        let template_version = None;
        let offset = None;

        eprintln!("DEBUG: parse_graphs called with: {}", pair.as_str());
        for graph_pair in pair.into_inner() {
            match graph_pair.as_rule() {
                Rule::graph_template => {}
                Rule::graph_block => {
                    for stmt_pair in graph_pair.into_inner() {
                        if stmt_pair.as_rule() == Rule::graph_stmt {
                            if let Ok(stmt_node) = self.parse_graph_stmt(stmt_pair) {
                                children.push(stmt_node);
                            }
                        }
                    }
                }
                Rule::as_stmt => {
                    // Handle alias
                    let position = self.get_position(&graph_pair);
                    alias = Some(Symbol {
                        position,
                        name: graph_pair.as_str().to_string(),
                        kind: SymbolKind::VarRef,
                    });
                }
                _ => {}
            }
        }

        eprintln!("DEBUG: GraphDef created with {} children", children.len());

        Ok(AstNodeEnum::GraphDef(GraphDef {
            position,
            children,
            alias,
            version,
            template_graph,
            template_version,
            offset,
        }))
    }

    fn parse_op_def(&mut self, _pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        // Simplified op parsing - implement based on needs
        Ok(AstNodeEnum::OpDef(OpDef {
            position: Position::new(1, 1, 1),
            children: vec![],
            alias: None,
            version: None,
            offset: None,
        }))
    }

    fn parse_comment(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let value = pair.as_str().to_string();

        Ok(AstNodeEnum::Comment(Comment { position, value }))
    }

    fn parse_value(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::STRING => return self.parse_string_literal(inner_pair),
                Rule::MULTI_LINE_STRING => return self.parse_multiline_string_literal(inner_pair),
                Rule::NUMBER => return self.parse_number_literal(inner_pair),
                Rule::FLOAT => return self.parse_float_literal(inner_pair),
                Rule::BOOL => return self.parse_bool_literal(inner_pair),
                Rule::DATETIME => return self.parse_datetime_literal(inner_pair),
                Rule::NULL => return self.parse_null_literal(inner_pair),
                Rule::dict_stmt => return self.parse_dict_statement(inner_pair),
                Rule::list_stmt => return self.parse_list_statement(inner_pair),
                Rule::tuple_stmt => return self.parse_tuple_statement(inner_pair),
                Rule::set_stmt => return self.parse_set_statement(inner_pair),
                Rule::date_stmt => return self.parse_date_statement(inner_pair),
                _ => {}
            }
        }
        Err(ParseError::general("Unknown value type"))
    }

    fn parse_string_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let raw_value = pair.as_str();

        // Remove quotes and unescape
        let content = &raw_value[1..raw_value.len() - 1];
        let value = self.unicode_escape_tool.unescape(content);

        Ok(AstNodeEnum::StringLiteral(StringLiteral {
            position,
            value,
        }))
    }

    fn parse_multiline_string_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let raw_value = pair.as_str();

        // Remove triple quotes and unescape
        let content = &raw_value[3..raw_value.len() - 3];
        let value = self.unicode_escape_tool.unescape(content);

        Ok(AstNodeEnum::MultiLineStringLiteral(
            MultiLineStringLiteral { position, value },
        ))
    }

    fn parse_number_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let raw = pair.as_str().to_string();
        let value = raw.parse::<i64>().map_err(|_| {
            ParseError::invalid_value("Invalid number", position.line, position.start)
        })?;

        Ok(AstNodeEnum::NumberLiteral(NumberLiteral {
            position,
            raw,
            value,
        }))
    }

    fn parse_float_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let raw = pair.as_str().to_string();
        let value = raw.parse::<f64>().map_err(|_| {
            ParseError::invalid_value("Invalid float", position.line, position.start)
        })?;

        Ok(AstNodeEnum::FloatLiteral(FloatLiteral {
            position,
            raw,
            value,
        }))
    }

    fn parse_bool_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let raw = pair.as_str().to_string();
        let value = raw.to_lowercase() == "true";

        Ok(AstNodeEnum::BoolLiteral(BoolLiteral {
            position,
            raw,
            value,
        }))
    }

    fn parse_datetime_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let raw = pair.as_str().to_string();

        // Add deprecation warning
        self.add_warning(ParseError::deprecated_feature(
            "datetime literal",
            position.line,
            position.start,
            "Please use date(\"2025-01-01 00:00:00\") to specify dates",
        ));

        let value = DateTime::parse_from_rfc3339(&raw)
            .map(|dt| dt.with_timezone(&Utc))
            .map_err(|_| {
                ParseError::invalid_value("Invalid datetime", position.line, position.start)
            })?;

        Ok(AstNodeEnum::DateTimeLiteral(DateTimeLiteral {
            position,
            raw,
            value,
        }))
    }

    fn parse_null_literal(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        Ok(AstNodeEnum::NullLiteral(NullLiteral { position }))
    }

    fn parse_dict_statement(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::dict_block {
                for dict_item_pair in inner_pair.into_inner() {
                    if dict_item_pair.as_rule() == Rule::key_value {
                        items.push(self.parse_dict_item(dict_item_pair)?);
                    }
                }
            }
        }

        Ok(AstNodeEnum::DictStatement(DictStatement {
            position,
            items,
        }))
    }

    fn parse_dict_item(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<DictItem> {
        let position = self.get_position(&pair);
        let mut inner_pairs = pair.into_inner();

        let key_pair = inner_pairs.next().ok_or_else(|| {
            ParseError::syntax_error(position.line, position.start, "Expected dict key")
        })?;
        let key = self.parse_string_literal(key_pair)?;

        // Skip COLON
        inner_pairs.next();

        let value_pair = inner_pairs.next().ok_or_else(|| {
            ParseError::syntax_error(position.line, position.start, "Expected dict value")
        })?;
        let value = self.parse_value(value_pair)?;

        Ok(DictItem {
            position,
            key: Box::new(key),
            value: Box::new(value),
        })
    }

    fn parse_list_statement(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::list_block {
                for value_pair in inner_pair.into_inner() {
                    if let Ok(value) = self.parse_value(value_pair) {
                        items.push(value);
                    }
                }
            }
        }

        Ok(AstNodeEnum::ListStatement(ListStatement {
            position,
            items,
        }))
    }

    fn parse_tuple_statement(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::tuple_block {
                for value_pair in inner_pair.into_inner() {
                    if let Ok(value) = self.parse_value(value_pair) {
                        items.push(value);
                    }
                }
            }
        }

        Ok(AstNodeEnum::TupleStatement(TupleStatement {
            position,
            items,
        }))
    }

    fn parse_set_statement(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::set_block {
                for value_pair in inner_pair.into_inner() {
                    if let Ok(value) = self.parse_value(value_pair) {
                        items.push(value);
                    }
                }
            }
        }

        Ok(AstNodeEnum::SetStatement(SetStatement { position, items }))
    }

    fn parse_date_statement(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut inner_pairs = pair.into_inner();

        // Skip 'date' keyword
        inner_pairs.next();

        // Skip LPAREN
        inner_pairs.next();

        let string_pair = inner_pairs.next().ok_or_else(|| {
            ParseError::syntax_error(position.line, position.start, "Expected date string")
        })?;

        let raw_value = string_pair.as_str();
        let content = &raw_value[1..raw_value.len() - 1]; // Remove quotes

        Ok(AstNodeEnum::DateLiteral(DateLiteral {
            position,
            value: content.to_string(),
        }))
    }

    fn parse_if_condition(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        match pair.as_rule() {
            Rule::if_condition => {
                for inner_pair in pair.into_inner() {
                    match inner_pair.as_rule() {
                        Rule::STRING | Rule::MULTI_LINE_STRING => {
                            return self.parse_string_literal(inner_pair);
                        }
                        _ => {}
                    }
                }
            }
            _ => {}
        }
        Err(ParseError::general("Invalid if condition"))
    }

    fn parse_symbol(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
        kind: SymbolKind,
    ) -> ParseResult<Symbol> {
        let position = self.get_position(&pair);
        let name = pair.as_str().to_string();

        Ok(Symbol {
            position,
            name,
            kind,
        })
    }

    fn parse_dotted_name_as_symbol(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
        kind: SymbolKind,
    ) -> ParseResult<Symbol> {
        let position = self.get_position(&pair);
        let mut name_parts = Vec::new();

        for inner_pair in pair.into_inner() {
            name_parts.push(inner_pair.as_str());
        }

        let name = name_parts.join(".");

        Ok(Symbol {
            position,
            name,
            kind,
        })
    }

    fn get_position(&self, pair: &pest::iterators::Pair<Rule>) -> Position {
        let span = pair.as_span();
        let (line, col) = span.start_pos().line_col();
        let (end_line, end_col) = span.end_pos().line_col();

        Position {
            line,
            end_line,
            start: col,
            end: end_col,
        }
    }

    fn add_error(&mut self, error: ParseError) {
        self.errors.add_error(error);
    }

    fn add_warning(&mut self, warning: ParseError) {
        self.errors.add_warning(warning);
    }
    fn parse_graph_stmt(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        let mut stmt_pair = pair.into_inner();
        if let Some(next_pair) = stmt_pair.next() {
            match next_pair.as_rule() {
                Rule::comment => return self.parse_comment(next_pair),
                Rule::dotted_identifiers => {
                    next_pair.as_str();
                }
                _ => return Err(ParseError::general("Invalid graph statement")),
            }
        }
        // skip DEFINED_BY
        stmt_pair.next();
        if let Some(next_pair) = stmt_pair.next() {
            match next_pair.as_rule() {
                Rule::value => {}
                Rule::dotted_identifiers => {}
                Rule::node_block => {
                    // parse_node_func_block_as_node_block
                }
                Rule::for_loop_block => {}
                Rule::condition_section => {}
                _ => return Err(ParseError::general("Invalid graph statement")),
            }
        }
        Err(ParseError::general("Unknown graph statement type"))
    }

    fn parse_graph_prop_def(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut name = String::new();
        let mut value = None;

        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::all_identifier => {
                    name = inner_pair.as_str().to_string();
                }
                Rule::value => {
                    value = Some(self.parse_value(inner_pair)?);
                }
                Rule::node_block => {
                    value = Some(self.parse_node_func_block(inner_pair)?);
                }
                Rule::dotted_name => {
                    // Handle graph_ref_def case
                    value = Some(AstNodeEnum::Symbol(
                        self.parse_dotted_name_as_symbol(inner_pair, SymbolKind::VarRef)?,
                    ));
                }
                _ => {}
            }
        }

        Ok(AstNodeEnum::AttrDef(AttrDef {
            position: position.clone(),
            name: Symbol {
                position: position.clone(),
                name,
                kind: SymbolKind::VarRef,
            },
            value: Box::new(value.unwrap_or(AstNodeEnum::NullLiteral(NullLiteral {
                position: position.clone(),
            }))),
            condition: None,
            else_value: None,
        }))
    }

    fn parse_node_func_block(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut name = String::new();
        let mut _inputs: Vec<AstNodeEnum> = Vec::new();
        let mut _attributes: Vec<AstNodeEnum> = Vec::new();

        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::dotted_name => {
                    name = inner_pair.as_str().to_string();
                }
                Rule::inputs_def => {
                    // Parse inputs if needed
                }
                Rule::node_attrs => {
                    // Parse attributes like .with(...)
                    for attr_pair in inner_pair.into_inner() {
                        if attr_pair.as_rule() == Rule::node_param_block {
                            // Parse parameters
                        }
                    }
                }
                _ => {}
            }
        }

        Ok(AstNodeEnum::Comment(Comment {
            position,
            value: format!("NodeFuncCall: {}", name),
        }))
    }

    fn parse_condition_def(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        Ok(AstNodeEnum::Comment(Comment {
            position,
            value: "condition_def".to_string(),
        }))
    }

    fn parse_node_def(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<AstNodeEnum> {
        let position = self.get_position(&pair);
        let mut outputs = Vec::new();
        let mut node_block = None;

        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::dotted_identifiers => {
                    // Parse output identifiers
                    for id_pair in inner_pair.into_inner() {
                        if id_pair.as_rule() == Rule::dotted_name {
                            let symbol =
                                self.parse_dotted_name_as_symbol(id_pair, SymbolKind::NodeOutput)?;
                            outputs.push(symbol);
                        }
                    }
                }
                Rule::all_identifier => {
                    // Single output identifier
                    let symbol = self.parse_symbol(inner_pair, SymbolKind::NodeOutput)?;
                    outputs.push(symbol);
                }
                Rule::node_block => {
                    node_block = Some(self.parse_node_func_block_as_node_block(inner_pair)?);
                }
                _ => {}
            }
        }

        Ok(AstNodeEnum::NodeDef(NodeDef {
            position: position.clone(),
            outputs,
            value: node_block.unwrap_or_else(|| NodeBlock {
                position: position.clone(),
                name_or_ref: Symbol::new(position.clone(), "unknown".to_string()),
                inputs: None,
                attrs: None,
            }),
        }))
    }

    fn parse_node_func_block_as_node_block(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<NodeBlock> {
        let position = self.get_position(&pair);
        let mut name_or_ref = Symbol::new(position.clone(), "unknown".to_string());
        let mut inputs = None;
        let mut attrs = Vec::new();

        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::dotted_name => {
                    name_or_ref =
                        self.parse_dotted_name_as_symbol(inner_pair, SymbolKind::NodeName)?;
                }
                Rule::inputs_def => {
                    inputs = Some(self.parse_node_inputs_def(inner_pair)?);
                }
                Rule::node_attrs => {
                    // Parse node function attributes like .version("1.0.0")
                    for attr_pair in inner_pair.into_inner() {
                        if let Ok(attr) = self.parse_node_func_attr(attr_pair) {
                            attrs.push(attr);
                        }
                    }
                }
                _ => {}
            }
        }

        Ok(NodeBlock {
            position,
            name_or_ref,
            inputs,
            attrs: if attrs.is_empty() { None } else { Some(attrs) },
        })
    }

    fn parse_node_inputs_def(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<NodeInputDef> {
        let position = self.get_position(&pair);
        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::inputs_tuple_def => {
                    return self.parse_inputs_tuple(inner_pair);
                }
                Rule::inputs_key_defs => {
                    return self.parse_inputs_key_defs(inner_pair);
                }
                _ => {}
            }
        }

        // Empty inputs
        Ok(NodeInputDef::Tuple(NodeInputTuple {
            position,
            items: vec![],
        }))
    }

    fn parse_inputs_tuple(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<NodeInputDef> {
        let position = self.get_position(&pair);
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::inputs_tuple_def {
                for tuple_item in inner_pair.into_inner() {
                    match tuple_item.as_rule() {
                        Rule::dotted_name => {
                            let symbol = self
                                .parse_dotted_name_as_symbol(tuple_item, SymbolKind::NodeInput)?;
                            items.push(symbol);
                        }
                        _ => {}
                    }
                }
            }
        }

        Ok(NodeInputDef::Tuple(NodeInputTuple { position, items }))
    }

    fn parse_inputs_key_defs(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<NodeInputDef> {
        let position = self.get_position(&pair);
        let mut items = Vec::new();

        for inner_pair in pair.into_inner() {
            if inner_pair.as_rule() == Rule::inputs_key_def {
                if let Ok(key_item) = self.parse_inputs_key_def(inner_pair) {
                    items.push(key_item);
                }
            }
        }

        Ok(NodeInputDef::KeyValue(NodeInputKeyDef { position, items }))
    }

    fn parse_inputs_key_def(
        &mut self,
        pair: pest::iterators::Pair<Rule>,
    ) -> ParseResult<NodeInputKeyItem> {
        let position = self.get_position(&pair);
        let mut key = Symbol::new(position.clone(), "unknown".to_string());
        let mut value_items = Vec::new();

        let mut inner_pairs = pair.into_inner();

        if let Some(key_pair) = inner_pairs.next() {
            key = self.parse_dotted_name_as_symbol(key_pair, SymbolKind::NodeInputKey)?;
        }

        if let Some(value_pair) = inner_pairs.next() {
            // Parse input_identifiers_paren
            for id_pair in value_pair.into_inner() {
                if id_pair.as_rule() == Rule::dotted_name {
                    let symbol =
                        self.parse_dotted_name_as_symbol(id_pair, SymbolKind::NodeInput)?;
                    value_items.push(symbol);
                }
            }
        }

        Ok(NodeInputKeyItem {
            position: position.clone(),
            key,
            value: NodeInputValues {
                position,
                items: value_items,
            },
        })
    }

    fn parse_node_func_attr(&mut self, pair: pest::iterators::Pair<Rule>) -> ParseResult<NodeAttr> {
        let position = self.get_position(&pair);
        let mut name = Symbol::new(position.clone(), "unknown".to_string());
        let mut value = NodeAttrValue::Symbol(Symbol::new(position.clone(), "".to_string()));

        // Parse .version("1.0.0") style attributes
        for inner_pair in pair.into_inner() {
            match inner_pair.as_rule() {
                Rule::version => {
                    name = Symbol::new(position.clone(), "version".to_string())
                        .with_kind(SymbolKind::NodeAttr);
                }
                Rule::name => {
                    name = Symbol::new(position.clone(), "name".to_string())
                        .with_kind(SymbolKind::NodeAttr);
                }
                Rule::depend => {
                    name = Symbol::new(position.clone(), "depend".to_string())
                        .with_kind(SymbolKind::NodeAttr);
                }
                Rule::with => {
                    name = Symbol::new(position.clone(), "with".to_string())
                        .with_kind(SymbolKind::NodeAttr);
                }
                Rule::as_keyword => {
                    name = Symbol::new(position.clone(), "as".to_string())
                        .with_kind(SymbolKind::NodeAttr);
                }
                Rule::STRING => {
                    let string_content = inner_pair.as_str();
                    let unquoted = &string_content[1..string_content.len() - 1]; // Remove quotes
                    value = NodeAttrValue::String(StringLiteral {
                        position: self.get_position(&inner_pair),
                        value: unquoted.to_string(),
                    });
                }
                _ => {}
            }
        }

        Ok(NodeAttr {
            position,
            name,
            value,
            offset: None,
        })
    }
}

/// Unicode escape tool for handling string escapes
struct UnicodeEscapeTool {
    escape_regex: Regex,
}

impl UnicodeEscapeTool {
    fn new() -> Self {
        Self {
            escape_regex: Regex::new(r"\\(.)").unwrap(),
        }
    }

    fn unescape(&self, input: &str) -> String {
        self.escape_regex
            .replace_all(input, |caps: &regex::Captures| match &caps[1] {
                "n" => "\n".to_string(),
                "t" => "\t".to_string(),
                "r" => "\r".to_string(),
                "\\" => "\\".to_string(),
                "\"" => "\"".to_string(),
                "'" => "'".to_string(),
                other => other.to_string(),
            })
            .to_string()
    }
}
